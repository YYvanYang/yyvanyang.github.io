---
layout: post
title:  "reset揭秘"
---

## 第 1 步：移动 HEAD
```
git reset --soft HEAD~
```
`它本质上是撤销了上一次 git commit 命令。` 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了,如下图，
![](../images/reset--soft.png)

备注：它将包含从HEAD～开始之后的所有修改。(用途之一：压缩提交，即将多个commit信息合并为一笔)

## 第 2 步：更新索引（--mixed）
`git reset [--mixed] HEAD~`
它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。
![](../images/reset--mixed.png)

## 第 3 步：更新工作目录（--hard）
`git reset --hard HEAD~`
你撤销了最后的提交、git add 和 git commit 命令以及工作目录中的所有工作。
![](../images/reset--hard.png)

必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。

## 通过路径来重置
TODO